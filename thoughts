TODO:

Eternity work in progress:
* Shakedown of GC amost done
	* Make sure deallocations occur within the same pulse. IMPORTANT
    * Make it possible to deallocate "on the fly" when not referred anymore...? (skip? dellocation list is robust/good enought)
* Create an index class. IMPORTANT
* Incoming structures enhandement:
	* Refactor and create the incoming observation interface. IMPORTANT
	* Make sure incoming structures are removed+deallocated when not needed. IMPORTANT BUT CAN WAIT
	* Make sure loaded incoming references is updated upon adding and removal of persistent objects.  IMPORTANT BUT CAN WAIT
* Activate: event.isConsequence in causality... IMPORTANT

* Store reactive primitives persistently
	* Modify causality to use methods rather than functions. POSTPONE TO LATER
	* Store observers persistently.  POSTPONE TO LATER
* Move more things to the state object POSTPONE TO LATER
* Optimization of GC, use depth count to try early reattatch.  POSTPONE TO LATER
* Connect to an actual database. POSTPONE TO LATER

Next Major Step:
* Convert old Liquid In progress.... 




Thoughts:

TODO: What about modifying incoming without actually loading it... this could make it easier to synch incoming/outgoing pairs without the risk of preemption in the middle, that expose incoming/outgoing imbalance.... 
TODO: What about if we are observing while modifying a reference when we have incoming structures as objects. We need to turn off recording while we modify the incoming structures...



General back references are needed in order to solve the doctor/patient problem.
Back references are not automatically streamed. 
forAllIncoming will loop through all available incoming. 

On the client it means only those incoming that are loaded, on the server it means all incoming in persistent storage. It could also mean that execution has to be asynchronous and take an object/method as function.

The client/doctor problem is solved by only loading outgoing references, and having back-references evaluated locally. If a user cannot load a specific medical record, he/she cannot 

The concept of LOUI

limited outgoing / unlimited incoming
 
Indicies cannot have weak links, this is because removal from an index usually requires more than just removing the outgoing link. There needs to be rebalancing, updating of tree properties etc. 



http://fgnass.github.io/spin.js/

Killing: 

When killing an object, nullify corresponding object on image. 

When killing an image change dbImage to dbId on object. Make sure it has a loadObjectFromId initializer. Remove from dbIdToImageMap.

Unload object should not destroy incoming relations... These are not saved and might be irreplaceable... we have to wait until there are no references to kill the object. 

When adding incoming references on objects, do we really need to load object if it is a placeholder?...
For incoming references to an image, we need to load the image before adding to them.

However, when adding incoming references to a dbImage we need to load it for proper placement of incoming references... 


 