TODO:

Eternity work in progress:
* Create a B-tree for the index. IMPORTANT BUT CAN WAIT
* Incoming structures enhandement:
	* Should we really use getSpecifier to create incoming structure???... 
	* Make sure incoming structures are removed+deallocated when not needed. IMPORTANT
	* Refactor and create the incoming observation interface. IMPORTANT
	* Make sure loaded incoming references is updated upon adding and removal of persistent objects.  IMPORTANT BUT CAN WAIT
* Make it possible to run incoming references without incoming structures as causality objects IMPORTANT (done?)... 

Next Major Step:
* Convert old Liquid In progress.... 


Future (persistent reactive structures.):
* Store reactive primitives persistently
	* Modify causality to use methods rather than functions. POSTPONE TO LATER
	* Store observers persistently.  POSTPONE TO LATER
* Move more things to the state object POSTPONE TO LATER
* Optimization of GC, use depth count to try early reattatch.  POSTPONE TO LATER
* Connect to an actual database. POSTPONE TO LATER


Thoughts:
TODO: What if two two phase commits interleave... should be have a list of comits, and have a push/shift algorithm... 
TODO: A zombie has no incoming references, but what happens when you refer a zombie object... ? Initialization will be run before getting the incoming structure... Create a state variable that controls if incoming can be manipulated on non-initialized object.... should only apply to non-zombies... 
TODO: What about modifying incoming without actually loading it... this could make it easier to synch incoming/outgoing pairs without the risk of preemption in the middle, that expose incoming/outgoing imbalance.... 
TODO: What about if we are observing while modifying a reference when we have incoming structures as objects. We need to turn off recording while we modify the incoming structures...



General back references are needed in order to solve the doctor/patient problem.
Back references are not automatically streamed. 
forAllIncoming will loop through all available incoming. 

On the client it means only those incoming that are loaded, on the server it means all incoming in persistent storage. It could also mean that execution has to be asynchronous and take an object/method as function.

The client/doctor problem is solved by only loading outgoing references, and having back-references evaluated locally. If a user cannot load a specific medical record, he/she cannot 

The concept of LOUI

limited outgoing / unlimited incoming
 
Indicies cannot have weak links, this is because removal from an index usually requires more than just removing the outgoing link. There needs to be rebalancing, updating of tree properties etc. 



http://fgnass.github.io/spin.js/

Killing: 

When killing an object, nullify corresponding object on image. 

When killing an image change dbImage to dbId on object. Make sure it has a loadObjectFromId initializer. Remove from dbIdToImageMap.

Unload object should not destroy incoming relations... These are not saved and might be irreplaceable... we have to wait until there are no references to kill the object. 

When adding incoming references on objects, do we really need to load object if it is a placeholder?...
For incoming references to an image, we need to load the image before adding to them.

However, when adding incoming references to a dbImage we need to load it for proper placement of incoming references... 


 